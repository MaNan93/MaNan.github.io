<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>IEEE Standard 754 Floating Point Numbers</title>
  
  <link rel="sitemap" href="http://manan.ccsitemap.xml" />
  
  <link rel="canonical" href="http://manan.cc/IEEE-Standard-754-Floating-Point-Numbers/2021/07/29/">
  
  <meta name="description" content="IEEE Standard 754 floating point is the most common representation today for real numbers on computers, including Intel-based PC’s, Macintoshes, and m">
  
  
  <meta name="author" content="MaNan">
  
  <meta property="og:image" content="http://manan.ccundefined">
  
  <meta property="og:site_name" content="Hexo" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="IEEE Standard 754 Floating Point Numbers" />
  
  <meta property="og:description" content="IEEE Standard 754 floating point is the most common representation today for real numbers on computers, including Intel-based PC’s, Macintoshes, and m">
  
  <meta property="og:url" content="http://manan.cc/IEEE-Standard-754-Floating-Point-Numbers/2021/07/29/" />

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="IEEE Standard 754 Floating Point Numbers">
  
  <meta name="twitter:description" content="IEEE Standard 754 floating point is the most common representation today for real numbers on computers, including Intel-based PC’s, Macintoshes, and m">
  
  
  <meta name="twitter:image" content="http://manan.ccundefined">
  
  <meta name="twitter:url" content="http://manan.cc/IEEE-Standard-754-Floating-Point-Numbers/2021/07/29/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="../fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="../fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  
  
<link rel="stylesheet" href="/css/user.css">

  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body>
  <div class="container">
    <div class="row">
      <div>

        <div class="row">
  <div class="two columns" style="max-width: 50px">
    <h1 class="mt-2 mode">
      <div onclick=setDarkMode(true) id="darkBtn">🌙</div>
      <div onclick=setDarkMode(false) id="lightBtn" class=hidden>☀️</div>
      <script >
        if (localStorage.getItem('preferredTheme') == 'dark') {
          setDarkMode(true)
        }
        function setDarkMode(isDark) {
          var darkBtn = document.getElementById('darkBtn')
          var lightBtn = document.getElementById('lightBtn')
          if (isDark) {
            lightBtn.style.display = "block"
            darkBtn.style.display = "none"
            localStorage.setItem('preferredTheme', 'dark');
          } else {
            lightBtn.style.display = "none"
            darkBtn.style.display = "block"
            localStorage.removeItem('preferredTheme');
          }
          document.body.classList.toggle("darkmode");
        }
      </script>
    </h1>
  </div>

  <div class="six columns ml-1">
    <h1 class="mt-2">
      Hola!
    </h1>
  </div>

  <div class="twelve columns">
    <div class="row">
      <div class="nine columns left">
        <a href="/">Home</a>
        
          
          <a target="_blank" rel="noopener" href="https://www.xidian.edu.cn/" class="ml">Works</a>
          
        
          
          <a href="/about/me" class="ml">AboutMe</a>
          
        
        
          
            <a href="mailto:manan93@live.com" target="_blank" class="ml">Email</a>
          
        
      </div>
    </div>
    <hr style="margin-bottom: 2.6rem">
  </div>
</div>

        <div class="trans">
            <h2>IEEE Standard 754 Floating Point Numbers</h2>

  <p>IEEE Standard 754 floating point is the most common representation today for real numbers on computers, including Intel-based PC’s, Macintoshes, and most Unix platforms. This article gives a brief overview of IEEE floating point and its representation. Discussion of arithmetic implementation may be found in the book mentioned at the bottom of this article.</p>
<blockquote>
<p>《IEEE Standard 754 floating point》是现如今在计算机表示实际数最普遍的方法，包括intel平台的个人电脑，麦金塔电脑和最广泛的Unix平台.本文对其作了简要的概述和举例表示。关于算术表示的讨论请参阅本文末尾提到的书籍。</p>
</blockquote>
<blockquote>
<p><em>Author（原作者）: Steve Hollasch</em><br>You may visit the site（你可以访问原始链接）: <a target="_blank" rel="noopener" href="https://steve.hollasch.net/cgindex/coding/ieeefloat.html">https://steve.hollasch.net/cgindex/coding/ieeefloat.html</a></p>
</blockquote>
<h2 id="What-Are-Floating-Point-Numbers"><a href="#What-Are-Floating-Point-Numbers" class="headerlink" title="What Are Floating Point Numbers?"></a>What Are Floating Point Numbers?</h2><p>There are several ways to represent real numbers on computers. Fixed point places a radix point somewhere in the middle of the digits, and is equivalent to using integers that represent portions of some unit. For example, one might represent 1/100ths of a unit; if you have four decimal digits, you could represent 10.82, or 00.01. Another approach is to use rationals, and represent every number as the ratio of two integers.</p>
<blockquote>
<p>什么是浮点数？</p>
<p>在计算机中有多种方式来表示实际数值。定点，是将小数点放置在数字的中间，也就是使用整数来表示某个单位的一部分。举个例子，1可以代表某个单位的1/100；假如有4个十进制的数字，那它们可能构成10.82或者00.01。还有种方式是采用有理数，用两个整数的比值来表示数字。</p>
</blockquote>
<p>Floating-point representation – the most common solution – uses scientific notation to encode numbers, with a base number and an exponent. For example, 123.456 could be represented as 1.23456 × 10<sup>2</sup>. In hexadecimal, the number 123.abc might be represented as 1.23abc × 16<sup>2</sup>. In binary, the number 10100.110 could be represented as 1.0100110 × 2<sup>4</sup>.</p>
<blockquote>
<p>浮点表示法——最常见的表示法——采用科学计数法来表示数字，由基数和指数来表示。比如，123.456可以写成1.23456 × 10<sup>2</sup>。十六进制中，123.abc可以写成1.23abc × 16<sup>2</sup> 。同样在二进制中，10100.110可表示为1.0100110 × 2<sup>4</sup>。</p>
</blockquote>
<p>Floating-point solves a number of representation problems. Fixed-point has a fixed window of representation, which limits it from representing both very large and very small numbers. Also, fixed-point is prone to a loss of precision when two large numbers are divided.</p>
<blockquote>
<p>浮点表示法能解决如何表示数字的问题。而定点数表示法的表示窗口（注：也就是当定点位宽确定时，它的最大值和最小值就确定了）是受限的，导致定点既不能表示非常大的数，也不能表示特别小的数。并且定点表示法在两个较大数字相除的时候会有精度损失。</p>
</blockquote>
<p>Floating-point, on the other hand, employs a sort of “sliding window” of precision appropriate to the scale of the number. This allows it to represent numbers from 1,000,000,000,000 to 0.0000000000000001 with ease, and while maximizing precision (the number of digits) at both ends of the scale.</p>
<blockquote>
<p>另一方面，浮点数具有“浮动窗口”，可以根据数字的大小精确地变化。这使得浮点数很容易地表示出0.0000000000000001到1,000,000,000,000之间的数字，同时最大限度地保证两端的精度（取决于数字的位数）。</p>
</blockquote>
<h2 id="Storage-Layout"><a href="#Storage-Layout" class="headerlink" title="Storage Layout"></a>Storage Layout</h2><p>IEEE floating point numbers have three basic components: the sign, the exponent, and the mantissa. The mantissa is composed of the fraction and an implicit leading digit (explained below). The exponent base (2) is implicit and need not be stored.</p>
<blockquote>
<p>存储方式</p>
<p>IEEE浮点数由三个基本单元组成：符号位，指数和尾数。尾数由小数和一个隐含的前导位构成。前导位是隐含的，不需要存储。</p>
<p>注：the leading digit, the first digit of a number, 就是数字从左向右数的第一位。在计算机中，存储数是以二进制格式存储。那么它的前导数只能是0或者1，比如0.xxxxxx或者1.xxxxxx，那对应的前导数就没必要保存，只需要规定好前导数是0或者1就行了。</p>
</blockquote>
<p>The following table shows the layout for single (32-bit) and double (64-bit) precision floating-point values. The number of bits for each field are shown, followed by the bit ranges in square brackets. 00 = least-significant bit.</p>
<blockquote>
<p>下表是单精度（32位）和双精度（64位）浮点值的存储格式。每个域的位数范围如方括号内的数字所示。00表示最低位。</p>
</blockquote>
<p>​                                            <em>Floating Point Components</em></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Sign</th>
<th align="center">Exponent</th>
<th align="center">Fraction</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Single Precision</td>
<td align="center">1 [31]</td>
<td align="center">8 [30–23]</td>
<td align="center">23 [22–00]</td>
</tr>
<tr>
<td align="center">Double Precision</td>
<td align="center">1 [63]</td>
<td align="center">11 [62–52]</td>
<td align="center">52 [51–00]</td>
</tr>
</tbody></table>
<p>Laid out as bits, floating point numbers look like this:</p>
<blockquote>
<p>按位展示，浮点数长这样：</p>
</blockquote>
<p><font size=2>Single: <font color=red>S</font><font color=orange>EEEEEEE E</font><font color=green>FFFFFFF FFFFFFFF FFFFFFFF</font></font><br><font size=2>Double: <font color=red>S</font><font color=orange>EEEEEEE EEEE</font><font color=green>FFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF</font></font>  </p>
<h2 id="The-Sign-Bit"><a href="#The-Sign-Bit" class="headerlink" title="The Sign Bit"></a>The Sign Bit</h2><p>The sign bit is as simple as it gets: 0 denotes a positive number, and 1 denotes a negative number. Flipping the value of this bit flips the sign of the number.</p>
<blockquote>
<p>符号位比较简单，0代表整数，1代表负数。</p>
</blockquote>
<h2 id="The-Exponent"><a href="#The-Exponent" class="headerlink" title="The Exponent"></a>The Exponent</h2><p>The exponent field needs to represent both positive and negative exponents. To do this, a bias is added to the actual exponent in order to get the stored exponent. For IEEE single-precision floats, this value is 127. Thus, to express an exponent of zero, 127 is stored in the exponent field. A stored value of 200 indicates an exponent of (200−127), or 73. For reasons discussed later, exponents of −127 (all 0s) and +128 (all 1s) are reserved for special numbers.</p>
<p>Double precision has an 11-bit exponent field, with a bias of 1023.</p>
<blockquote>
<p>指数域分正数和负数。为了区分，引入了一个偏置数。IEEE单精度浮点数，这个偏置数是127. 因此指数是零对应偏置数是127，存储在指数域。200对应的指数（200-127）是73.原因在后面解释。指数域（8位，取值是0——255）全0代表-127（0-127），全1代表+128（255-127）.</p>
<p>双精度浮点数的指数域有11位，它的偏置数是1023.</p>
<p>注：盲猜偏置数bias = 2<sup>（ bit_num-1 ）</sup> - 1.</p>
<p>注：为什么要引入偏置数？个人认为，指数是有正负之分的，指数域没必要再引入一个符号位，那么需要引入一个偏置数来代替。也就是说，8bit的指数域，原本取值是 -127 ~ +128，引入偏置数（127）后取值是0~255，从而去掉了指数域的符号位。</p>
</blockquote>
<h2 id="The-Mantissa"><a href="#The-Mantissa" class="headerlink" title="The Mantissa"></a>The Mantissa</h2><p>The mantissa, also known as the significand, represents the precision bits of the number. It is composed of an implicit leading bit (left of the radix point) and the fraction bits (to the right of the radix point).</p>
<blockquote>
<p>尾数是很重要的，它体现了数字的精度。它由隐含的的先导位（小数点左边的部分）和小数位（小数点右边的部分）构成。</p>
</blockquote>
<p>To find out the value of the implicit leading bit, consider that any number can be expressed in scientific notation in many different ways. For example, the number 50 can be represented as any of these:</p>
<blockquote>
<p>为了了解什么是隐含的先导位，请看看用科学技术表示法表示一个数字的各种方式。举个例子：数字50可以写成这样：</p>
</blockquote>
<pre>
    0.050 × 10<sup>3</sup>
    .5000 × 10<sup>2</sup>
    5.000 × 10<sup>1</sup>
    50.00 × 10<sup>0</sup>
    5000. × 10<sup>−2</sup>  
</pre>
<p>In order to maximize the quantity of representable numbers, floating-point numbers are typically stored in normalized form. This basically puts the radix point after the first non-zero digit. In normalized form, 50 is represented as 5.000 × 10<sup>1</sup>.</p>
<blockquote>
<p>为了最大限度地表示数字，浮点数通常以标准化形式存储。将小数点放在第一个（从左往右数）非零数的右边。标准格式下，50就要表示成5.000 × 10<sup>1</sup>。</p>
</blockquote>
<p>A nice little optimization is now available to us in base two, since binary has only one possible non-zero digit: 1. Thus, we can just assume a leading digit of 1, and don’t need to store it in the floating-point representation. As a result, we can assume a leading digit of 1 without storing it, so that a 32-bit floating-point value effectively has 24 bits of mantissa: 23 explicit fraction bits plus one implicit leading bit of 1.</p>
<blockquote>
<p>可是在二进制当中我们可以做一点小小的优化，二进制数的第一个非零数只有1. 因此浮点表示法中，我们可以规定先导数就是数字1且没必要在保存它了。那么32位的浮点数值的尾数（规定是23位）等效为24位了：23位的显式小数部分加上一个隐含的先导位 1.</p>
</blockquote>
<h2 id="Putting-it-All-Together"><a href="#Putting-it-All-Together" class="headerlink" title="Putting it All Together"></a>Putting it All Together</h2><p>So, to sum up:</p>
<ol>
<li><p>The sign bit is 0 for positive, 1 for negative.</p>
</li>
<li><p>The exponent base is two.</p>
</li>
<li><p>The exponent field contains 127 plus the true exponent for single-precision, or 1023 plus the true exponent for double precision.</p>
</li>
<li><p>The first bit of the mantissa is typically assumed to be 1, yielding a full mantissa of 1.f, where f is the field of fraction bits.</p>
<blockquote>
<p>总结下：</p>
<ol>
<li>符号位0代表整数，1代表负数。</li>
<li>指数是二进制。</li>
<li>指数域的值是实际指数加上127（单精度）或者加上1023（双精度）。</li>
<li>尾数的第一位规定是1，尾数就是1.f，f指小数部分。</li>
</ol>
</blockquote>
<h2 id="Ranges-of-Floating-Point-Numbers"><a href="#Ranges-of-Floating-Point-Numbers" class="headerlink" title="Ranges of Floating-Point Numbers"></a>Ranges of Floating-Point Numbers</h2><p>Let’s consider single-precision floats for a second. We’re taking essentially a 32-bit number and reinterpreting the fields to cover a much broader range. Something has to give, and that something is precision. For example, regular 32-bit integers, with all precision centered around zero, can precisely store integers with 32-bits of resolution. Single-precision floating-point, on the other hand, is unable to match this resolution with its 24 bits. It does, however, approximate this value by effectively truncating from the lower end and rounding up. For example:</p>
</li>
</ol>
<blockquote>
<p>浮点数的表示范围</p>
<p>我们先来考虑下单精度。我们基本上采用 32 位数字并重新解释这些字段，从而可拓展到更大的范围。首先得指出精度范围。例如，所有以零为中心的32位整数，可以用32位的分辨力精准地存储整数。另外，单精度的浮点，它的24位可不足以匹配32位的分辨力。但是它确实可以，通过有效地从低端截断并向上取整来近似该值。</p>
</blockquote>
<pre>
    11110000 11001100 10101010 10101111  // 32-bit integer
= +1.1110000 11001100 10101011 x 2<sup>31</sup>     // Single-precision float
=   11110000 11001100 10101011 00000000  // Actual float value
</pre>
<p>This approximates the 32-bit value, but doesn’t yield an exact representation. On the other hand, besides the ability to represent fractional components (which integers lack completely), the floating-point value can represent numbers around 2<sup>127</sup>, compared to 32-bit integers’ maximum value around 2<sup>32</sup>.</p>
<blockquote>
<p>这只是近似的32位数值，不是准确的。另一方面，除了能表示小数部分（完全没有整数部分），浮点值也可以表示2<sup>127</sup>，而对比32比特的最大值是2<sup>32</sup>.</p>
</blockquote>
<p>The range of positive floating point numbers can be split into normalized numbers (which preserve the full precision of the mantissa), and denormalized numbers (which assume a leading digit of 0, discussed later) which use only a portion of the fractions’s precision.</p>
<blockquote>
<p>正浮点数的范围可以分为格式化数（保存尾数的全精度）和非格式化数（此时先导数是零）。</p>
</blockquote>
<p>​                                                      <em>Floating Point Range</em></p>
<table>
<thead>
<tr>
<th></th>
<th>Denormalized</th>
<th>Normalized</th>
<th>Approximate Decimal</th>
</tr>
</thead>
<tbody><tr>
<td>Single Precision</td>
<td>± 2<sup>-149</sup> to (1−2<sup>−23</sup>)×2<sup>-126</sup></td>
<td>± 2<sup>-126</sup> to (2−2<sup>−23</sup>)×2<sup>127</sup></td>
<td>± ≈10<sup>−44.85</sup> to ≈10<sup>38.53</sup></td>
</tr>
<tr>
<td>Double Precision</td>
<td>± 2<sup>−1074</sup> to (1−2<sup>−52</sup>) × 2<sup>−1022</sup></td>
<td>± 2<sup>−1022</sup> to (2−2<sup>−52</sup>)×2<sup>1023</sup></td>
<td>± ≈10<sup>−323.3</sup> to ≈10<sup>308.3</sup></td>
</tr>
</tbody></table>
<blockquote>
<p>后面有空再翻译。</p>
</blockquote>
<p>Since every floating-point number has a corresponding, negated value (by toggling the sign bit), the ranges above are symmetric around zero.</p>
<p>There are five distinct numerical ranges that single-precision floating-point numbers are not able to represent with the scheme presented so far:</p>
<ol>
<li>Negative numbers less than −(2−2<sup>−23</sup>) × 2<sup>127</sup> (negative overflow)</li>
<li>Negative numbers greater than −2<sup>−149</sup> (negative underflow)</li>
<li>Zero</li>
<li>Positive numbers less than 2<sup>−149</sup> (positive underflow)</li>
<li>Positive numbers greater than (2−2<sup>−23</sup>) × 2<sup>127</sup> (positive overflow)</li>
</ol>
<p>Overflow means that values have grown too large for the representation, much in the same way that you can overflow integers. Underflow is a less serious problem because is just denotes a loss of precision, which is guaranteed to be closely approximated by zero.</p>
<p>Here’s a table of the total effective range of finite IEEE floating-point numbers:</p>
<p>​                                            <em>Effective Floating-Point Range</em></p>
<table>
<thead>
<tr>
<th></th>
<th>Binary</th>
<th>Decimal</th>
</tr>
</thead>
<tbody><tr>
<td>Single</td>
<td>± (2−2<sup>−23</sup>) × 2<sup>127</sup></td>
<td>≈ ± 10<sup>38.53</sup></td>
</tr>
<tr>
<td>Double</td>
<td>± (2−2<sup>−52</sup>) × 2<sup>1023</sup></td>
<td>≈ ± 10<sup>308.25</sup></td>
</tr>
</tbody></table>
<p><em>Note that the extreme values occur (regardless of sign) when the exponent is at the maximum value for finite numbers (2<sup>127</sup> for single-precision, 2<sup>1023</sup> for double), and the mantissa is filled with 1s (including the normalizing 1 bit).</em></p>
<h2 id="Special-Values"><a href="#Special-Values" class="headerlink" title="Special Values"></a>Special Values</h2><p>IEEE reserves exponent field values of all 0s and all 1s to denote special values in the floating-point scheme.</p>
<h3 id="Denormalized"><a href="#Denormalized" class="headerlink" title="Denormalized"></a><em>Denormalized</em></h3><p>If the exponent is all 0s, then the value is a denormalized number, which now has an assumed leading 0 before the binary point. Thus, this represents a number (−1)s × 0.f × 2<sup>−126</sup>, where s is the sign bit and f is the fraction. For double precision, denormalized numbers are of the form (−1)s × 0.f × 2<sup>−1022</sup>.</p>
<p>As denormalized numbers get smaller, they gradually lose precision as the left bits of the fraction become zeros. At the smallest non-zero denormalized value (only the least-significant fraction bit is one), a 32-bit floating-point number has but a single bit of precision, compared to the standard 24-bits for normalized values.</p>
<h3 id="Zero"><a href="#Zero" class="headerlink" title="Zero"></a><em>Zero</em></h3><p>You can think of zero as a denormalized number (an implicit leading 0 bit) with all 0 fraction bits. Note that −0 and +0 are distinct values, though they both compare as equal.</p>
<h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a><em>Infinity</em></h3><p>The values +∞ and −∞ are denoted with an exponent of all 1s and a fraction of all 0s. The sign bit distinguishes between negative infinity and positive infinity. Being able to denote infinity as a specific value is useful because it allows operations to continue past overflow situations. Operations with infinite values are well defined in IEEE floating point.  </p>
<h3 id="Not-A-Number"><a href="#Not-A-Number" class="headerlink" title="Not A Number"></a><em>Not A Number</em></h3><p>The value NaN (Not a Number) is used to represent a value that does not represent a real number. NaN’s are represented by a bit pattern with an exponent of all 1s and a non-zero fraction. There are two categories of NaN: QNaN (Quiet NaN) and SNaN (Signalling NaN).</p>
<p>A QNaN is a NaN with the most significant fraction bit set. QNaN’s propagate freely through most arithmetic operations. These values are generated from an operation when the result is not mathematically defined.</p>
<p>An SNaN is a NaN with the most significant fraction bit clear. It can be used to signal an exception when used in operations. SNaN’s can be handy to assign to uninitialized variables to trap premature usage.</p>
<p>Semantically, QNaN’s denote indeterminate operations, while SNaN’s denote invalid operations.</p>
<h2 id="Special-Operations"><a href="#Special-Operations" class="headerlink" title="Special Operations"></a>Special Operations</h2><p>Operations on special numbers are well-defined by IEEE. In the simplest case, any operation with a NaN yields a NaN result. Other operations are as follows:</p>
<p>​                                                <em>Special Arithmetic Results</em></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>n ÷ ±∞</td>
<td>0</td>
</tr>
<tr>
<td>±∞ × ±∞</td>
<td>±∞</td>
</tr>
<tr>
<td>±nonZero ÷ ±0</td>
<td>±∞</td>
</tr>
<tr>
<td>±finite × ±∞</td>
<td>±∞</td>
</tr>
<tr>
<td>∞ + ∞ ∞ − −∞</td>
<td>+∞</td>
</tr>
<tr>
<td>−∞ − ∞ −∞ + −∞</td>
<td>−∞</td>
</tr>
<tr>
<td>∞ − ∞ −∞ + ∞</td>
<td>NaN</td>
</tr>
<tr>
<td>±0 ÷ ±0</td>
<td>NaN</td>
</tr>
<tr>
<td>±∞ ÷ ±∞</td>
<td>NaN</td>
</tr>
<tr>
<td>±∞ × 0</td>
<td>NaN</td>
</tr>
<tr>
<td>NaN == NaN</td>
<td>false</td>
</tr>
</tbody></table>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To sum up, the following are the corresponding values for a given representation:</p>
<p><em>Float Values (b = bias)</em><br><img src="FloatValues.png" alt="FlooatValues"></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>A lot of this stuff was observed from small programs I wrote to go back and forth between hex and floating point (printf-style), and to examine the results of various operations. The bulk of this material, however, was lifted from Stallings’ book.</p>
<ol>
<li><em>Computer Organization and Architecture, William Stallings, pp. 222–234 Macmillan Publishing Company, ISBN 0-02-415480-6</em></li>
<li><em>IEEE Computer Society (1985), IEEE Standard for Binary Floating-Point Arithmetic, IEEE Std 754-1985.</em></li>
<li><em>Intel Architecture Software Developer’s Manual, Volume 1: Basic Architecture, (a PDF document downloaded from <a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/homepage.html">intel.com</a>).</em></li>
</ol>
<h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul>
<li><p><em><a target="_blank" rel="noopener" href="https://standards.ieee.org/">IEEE Standards Site</a></em></p>
</li>
<li><p><em><a target="_blank" rel="noopener" href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">Comparing floating point numbers</a>, Bruce Dawson. This is an excellent article on the traps, pitfalls and solutions for comparing floating point numbers. Hint – epsilon comparison is usually the wrong solution.</em></p>
</li>
<li><p><em><a target="_blank" rel="noopener" href="https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/">That’s Not Normal – the Performance of Odd Floats</a>, Bruce Dawson. This is another good article covering performance issues with IEEE specials on x86 architecture.</em></p>
</li>
<li><p><em><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/314.html">IEEE 754浮点数标准详解</a></em></p>
</li>
</ul>

  <p> — 2021年7月29日</p>
  


          <div class="row mt-2">
  
    <div class="eight columns">
      <p id="madewith">Made with ❤ and
        <a class="footer-link icon" href="https://hexo.io" target="_blank" style="text-decoration: none;" rel="noreferrer" aria-label="Hexo.io">
        <svg class="hexo svg-hov" width="14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Hexo.js</title><path d="M12 .007L1.57 6.056V18.05L12 23.995l10.43-6.049V5.952L12 .007zm4.798 17.105l-.939.521-.939-.521V12.94H9.08v4.172l-.94.521-.938-.521V6.89l.939-.521.939.521v4.172h5.84V6.89l.94-.521.938.521v10.222z"/></svg>
        </a>
        
        at <a href="https://en.wikipedia.org/wiki/Earth" target="_blank" rel="noreferrer">Earth</a>.</p>
        
    </div>

    <!-- Sepcial thanks to https://simpleicons.org/ for the icons -->
    <div class="four columns mb-3 posisi" >
      
      <a class="ml-0 footer-link icon" href="https://github.com/MaNan93" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="GitHub">
        <svg class="github svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      </a>
      

      

      

      

      

    </div>
  
</div>

        </div>
      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>
  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>
