<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://manan.cc/atom.xml" rel="self"/>
  
  <link href="http://manan.cc/"/>
  <updated>2021-07-30T07:43:03.866Z</updated>
  <id>http://manan.cc/</id>
  
  <author>
    <name>MaNan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IEEE Standard 754 Floating Point Numbers</title>
    <link href="http://manan.cc/IEEE-Standard-754-Floating-Point-Numbers/2021/07/29/"/>
    <id>http://manan.cc/IEEE-Standard-754-Floating-Point-Numbers/2021/07/29/</id>
    <published>2021-07-29T09:37:26.000Z</published>
    <updated>2021-07-30T07:43:03.866Z</updated>
    
    <content type="html"><![CDATA[<p>IEEE Standard 754 floating point is the most common representation today for real numbers on computers, including Intel-based PC’s, Macintoshes, and most Unix platforms. This article gives a brief overview of IEEE floating point and its representation. Discussion of arithmetic implementation may be found in the book mentioned at the bottom of this article.</p><blockquote><p><em>Author: Steve Hollasch</em><br><em>You may visit the site: <a href="https://steve.hollasch.net/cgindex/coding/ieeefloat.html">https://steve.hollasch.net/cgindex/coding/ieeefloat.html</a></em></p></blockquote><h2 id="What-Are-Floating-Point-Numbers"><a href="#What-Are-Floating-Point-Numbers" class="headerlink" title="What Are Floating Point Numbers?"></a>What Are Floating Point Numbers?</h2><p>There are several ways to represent real numbers on computers. Fixed point places a radix point somewhere in the middle of the digits, and is equivalent to using integers that represent portions of some unit. For example, one might represent 1/100ths of a unit; if you have four decimal digits, you could represent 10.82, or 00.01. Another approach is to use rationals, and represent every number as the ratio of two integers.</p><p>Floating-point representation – the most common solution – uses scientific notation to encode numbers, with a base number and an exponent. For example, 123.456 could be represented as 1.23456 × 102. In hexadecimal, the number 123.abc might be represented as 1.23abc × 162. In binary, the number 10100.110 could be represented as 1.0100110 × 24.</p><p>Floating-point solves a number of representation problems. Fixed-point has a fixed window of representation, which limits it from representing both very large and very small numbers. Also, fixed-point is prone to a loss of precision when two large numbers are divided.</p><p>Floating-point, on the other hand, employs a sort of “sliding window” of precision appropriate to the scale of the number. This allows it to represent numbers from 1,000,000,000,000 to 0.0000000000000001 with ease, and while maximizing precision (the number of digits) at both ends of the scale.</p><h2 id="Storage-Layout"><a href="#Storage-Layout" class="headerlink" title="Storage Layout"></a>Storage Layout</h2><p>IEEE floating point numbers have three basic components: the sign, the exponent, and the mantissa. The mantissa is composed of the fraction and an implicit leading digit (explained below). The exponent base (2) is implicit and need not be stored.</p><p>The following table shows the layout for single (32-bit) and double (64-bit) precision floating-point values. The number of bits for each field are shown, followed by the bit ranges in square brackets. 00 = least-significant bit.</p><p><em>Floating Point Components</em></p><table><thead><tr><th></th><th align="center">Sign</th><th>Exponent</th><th>Fraction</th></tr></thead><tbody><tr><td>Single Precision</td><td align="center">1 [31]</td><td>8 [30–23]</td><td>23 [22–00]</td></tr><tr><td>Double Precision</td><td align="center">1 [63]</td><td>11 [62–52]</td><td>52 [51–00]</td></tr></tbody></table><p>Laid out as bits, floating point numbers look like this:</p><p><font size=2>Single: <font color=red>S</font><font color=orange>EEEEEEE E</font><font color=green>FFFFFFF FFFFFFFF FFFFFFFF</font></font><br><font size=2>Double: <font color=red>S</font><font color=orange>EEEEEEE EEEE</font><font color=green>FFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF</font></font>  </p><h2 id="The-Sign-Bit"><a href="#The-Sign-Bit" class="headerlink" title="The Sign Bit"></a>The Sign Bit</h2><p>The sign bit is as simple as it gets: 0 denotes a positive number, and 1 denotes a negative number. Flipping the value of this bit flips the sign of the number.</p><h2 id="The-Exponent"><a href="#The-Exponent" class="headerlink" title="The Exponent"></a>The Exponent</h2><p>The exponent field needs to represent both positive and negative exponents. To do this, a bias is added to the actual exponent in order to get the stored exponent. For IEEE single-precision floats, this value is 127. Thus, to express an exponent of zero, 127 is stored in the exponent field. A stored value of 200 indicates an exponent of (200<sup>−127</sup>), or 73. For reasons discussed later, exponents of −127 (all 0s) and +128 (all 1s) are reserved for special numbers.</p><p>Double precision has an 11-bit exponent field, with a bias of 1023.</p><h2 id="The-Mantissa"><a href="#The-Mantissa" class="headerlink" title="The Mantissa"></a>The Mantissa</h2><p>The mantissa, also known as the significand, represents the precision bits of the number. It is composed of an implicit leading bit (left of the radix point) and the fraction bits (to the right of the radix point).</p><p>To find out the value of the implicit leading bit, consider that any number can be expressed in scientific notation in many different ways. For example, the number 50 can be represented as any of these:</p><ul><li>   0.050 × 10<sup>3</sup></li><li>   .5000 × 10<sup>2</sup></li><li>   5.000 × 10<sup>1</sup></li><li>   50.00 × 10<sup>0</sup></li><li><ol start="5000"><li>× 10<sup>−2</sup></li></ol></li></ul><p>In order to maximize the quantity of representable numbers, floating-point numbers are typically stored in normalized form. This basically puts the radix point after the first non-zero digit. In normalized form, 50 is represented as 5.000 × 101.</p><p>A nice little optimization is now available to us in base two, since binary has only one possible non-zero digit: 1. Thus, we can just assume a leading digit of 1, and don’t need to store it in the floating-point representation. As a result, we can assume a leading digit of 1 without storing it, so that a 32-bit floating-point value effectively has 24 bits of mantissa: 23 explicit fraction bits plus one implicit leading bit of 1.</p><h2 id="Putting-it-All-Together"><a href="#Putting-it-All-Together" class="headerlink" title="Putting it All Together"></a>Putting it All Together</h2><p>So, to sum up:</p><ol><li><p>The sign bit is 0 for positive, 1 for negative.</p></li><li><p>The exponent base is two.</p></li><li><p>The exponent field contains 127 plus the true exponent for single-precision, or 1023 plus the true exponent for double precision.</p></li><li><p>The first bit of the mantissa is typically assumed to be 1, yielding a full mantissa of 1.f, where f is the field of fraction bits.</p><h2 id="Ranges-of-Floating-Point-Numbers"><a href="#Ranges-of-Floating-Point-Numbers" class="headerlink" title="Ranges of Floating-Point Numbers"></a>Ranges of Floating-Point Numbers</h2><p>Let’s consider single-precision floats for a second. We’re taking essentially a 32-bit number and reinterpreting the fields to cover a much broader range. Something has to give, and that something is precision. For example, regular 32-bit integers, with all precision centered around zero, can precisely store integers with 32-bits of resolution. Single-precision floating-point, on the other hand, is unable to match this resolution with its 24 bits. It does, however, approximate this value by effectively truncating from the lower end and rounding up. For example:</p><pre class="line-numbers language-none"><code class="language-none">    11110000 11001100 10101010 10101111  &#x2F;&#x2F; 32-bit integer&#x3D; +1.1110000 11001100 10101011 x 231     &#x2F;&#x2F; Single-precision float&#x3D;   11110000 11001100 10101011 00000000  &#x2F;&#x2F; Actual float value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>This approximates the 32-bit value, but doesn’t yield an exact representation. On the other hand, besides the ability to represent fractional components (which integers lack completely), the floating-point value can represent numbers around 2<sup>127</sup>, compared to 32-bit integers’ maximum value around 2<sup>32</sup>.</p><p>The range of positive floating point numbers can be split into normalized numbers (which preserve the full precision of the mantissa), and denormalized numbers (which assume a leading digit of 0, discussed later) which use only a portion of the fractions’s precision.</p><p><em>Floating Point Range</em></p><table><thead><tr><th></th><th>Denormalized</th><th>Normalized</th><th>Approximate Decimal</th></tr></thead><tbody><tr><td>Single Precision</td><td>± 2<sup>-149</sup> to (1−2<sup>−23</sup>)×2<sup>-126</sup></td><td>± 2<sup>-126</sup> to (2−2−23)×2<sup>127</sup></td><td>± ≈10<sup>−44.85</sup> to ≈10<sup>38.53</sup></td></tr><tr><td>Double Precision</td><td>± 2<sup>−1074</sup> to (1−2<sup>−52</sup>) × 2<sup>−1022</sup></td><td>± 2<sup>−1022</sup> to (2−2<sup>−52</sup>)×2<sup>1023</sup></td><td>± ≈10<sup>−323.3</sup> to ≈10<sup>308.3</sup></td></tr></tbody></table><p>Since every floating-point number has a corresponding, negated value (by toggling the sign bit), the ranges above are symmetric around zero.</p><p>There are five distinct numerical ranges that single-precision floating-point numbers are not able to represent with the scheme presented so far:</p><ol><li>Negative numbers less than −(2−2<sup>−23</sup>) × 2<sup>127</sup> (negative overflow)</li><li>Negative numbers greater than −2<sup>−149</sup> (negative underflow)</li><li>Zero</li><li>Positive numbers less than 2<sup>−149</sup> (positive underflow)</li><li>Positive numbers greater than (2−2<sup>−23</sup>) × 2<sup>127</sup> (positive overflow)</li></ol><p>Overflow means that values have grown too large for the representation, much in the same way that you can overflow integers. Underflow is a less serious problem because is just denotes a loss of precision, which is guaranteed to be closely approximated by zero.</p><p>Here’s a table of the total effective range of finite IEEE floating-point numbers:</p><p><em>Effective Floating-Point Range</em></p><table><thead><tr><th></th><th>Binary</th><th>Decimal</th></tr></thead><tbody><tr><td>Single</td><td>± (2−2<sup>−23</sup>) × 2<sup>127</sup></td><td>≈ ± 10<sup>38.53</sup></td></tr><tr><td>Double</td><td>± (2−2<sup>−52</sup>) × 2<sup>1023</sup></td><td>≈ ± 10<sup>308.25</sup></td></tr></tbody></table><p><em>Note that the extreme values occur (regardless of sign) when the exponent is at the maximum value for finite numbers (2<sup>127</sup> for single-precision, 2<sup>1023</sup> for double), and the mantissa is filled with 1s (including the normalizing 1 bit).</em></p><h2 id="Special-Values"><a href="#Special-Values" class="headerlink" title="Special Values"></a>Special Values</h2><p>IEEE reserves exponent field values of all 0s and all 1s to denote special values in the floating-point scheme.</p><h3 id="Denormalized"><a href="#Denormalized" class="headerlink" title="Denormalized"></a><em>Denormalized</em></h3><p>If the exponent is all 0s, then the value is a denormalized number, which now has an assumed leading 0 before the binary point. Thus, this represents a number (−1)s × 0.f × 2<sup>−126</sup>, where s is the sign bit and f is the fraction. For double precision, denormalized numbers are of the form (−1)s × 0.f × 2<sup>−1022</sup>.</p><p>As denormalized numbers get smaller, they gradually lose precision as the left bits of the fraction become zeros. At the smallest non-zero denormalized value (only the least-significant fraction bit is one), a 32-bit floating-point number has but a single bit of precision, compared to the standard 24-bits for normalized values.</p><h3 id="Zero"><a href="#Zero" class="headerlink" title="Zero"></a><em>Zero</em></h3><p>You can think of zero as a denormalized number (an implicit leading 0 bit) with all 0 fraction bits. Note that −0 and +0 are distinct values, though they both compare as equal.</p><h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a><em>Infinity</em></h3><p>The values +∞ and −∞ are denoted with an exponent of all 1s and a fraction of all 0s. The sign bit distinguishes between negative infinity and positive infinity. Being able to denote infinity as a specific value is useful because it allows operations to continue past overflow situations. Operations with infinite values are well defined in IEEE floating point.  </p><h3 id="Not-A-Number"><a href="#Not-A-Number" class="headerlink" title="Not A Number"></a><em>Not A Number</em></h3><p>The value NaN (Not a Number) is used to represent a value that does not represent a real number. NaN’s are represented by a bit pattern with an exponent of all 1s and a non-zero fraction. There are two categories of NaN: QNaN (Quiet NaN) and SNaN (Signalling NaN).</p><p>A QNaN is a NaN with the most significant fraction bit set. QNaN’s propagate freely through most arithmetic operations. These values are generated from an operation when the result is not mathematically defined.</p><p>An SNaN is a NaN with the most significant fraction bit clear. It can be used to signal an exception when used in operations. SNaN’s can be handy to assign to uninitialized variables to trap premature usage.</p><p>Semantically, QNaN’s denote indeterminate operations, while SNaN’s denote invalid operations.</p><h2 id="Special-Operations"><a href="#Special-Operations" class="headerlink" title="Special Operations"></a>Special Operations</h2><p>Operations on special numbers are well-defined by IEEE. In the simplest case, any operation with a NaN yields a NaN result. Other operations are as follows:</p><p><em>Special Arithmetic Results</em></p><table><thead><tr><th>Operation</th><th>Result</th></tr></thead><tbody><tr><td>n ÷ ±∞</td><td>0</td></tr><tr><td>±∞ × ±∞</td><td>±∞</td></tr><tr><td>±nonZero ÷ ±0</td><td>±∞</td></tr><tr><td>±finite × ±∞</td><td>±∞</td></tr><tr><td>∞ + ∞ ∞ − −∞</td><td>+∞</td></tr><tr><td>−∞ − ∞ −∞ + −∞</td><td>−∞</td></tr><tr><td>∞ − ∞ −∞ + ∞</td><td>NaN</td></tr><tr><td>±0 ÷ ±0</td><td>NaN</td></tr><tr><td>±∞ ÷ ±∞</td><td>NaN</td></tr><tr><td>±∞ × 0</td><td>NaN</td></tr><tr><td>NaN == NaN</td><td>false</td></tr></tbody></table><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To sum up, the following are the corresponding values for a given representation:</p><p><em>Float Values (b = bias)</em><br><img src="FloatValues.png" alt="FlooatValues"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>A lot of this stuff was observed from small programs I wrote to go back and forth between hex and floating point (printf-style), and to examine the results of various operations. The bulk of this material, however, was lifted from Stallings’ book.</p><ol><li><em>Computer Organization and Architecture, William Stallings, pp. 222–234 Macmillan Publishing Company, ISBN 0-02-415480-6</em></li><li><em>IEEE Computer Society (1985), IEEE Standard for Binary Floating-Point Arithmetic, IEEE Std 754-1985.</em></li><li><em>Intel Architecture Software Developer’s Manual, Volume 1: Basic Architecture, (a PDF document downloaded from <a href="https://www.intel.com/content/www/us/en/homepage.html">intel.com</a>).</em></li></ol><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><em><a href="https://standards.ieee.org/">IEEE Standards Site</a></em></li><li><em><a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">Comparing floating point numbers</a>, Bruce Dawson. This is an excellent article on the traps, pitfalls and solutions for comparing floating point numbers. Hint – epsilon comparison is usually the wrong solution.</em></li><li><em><a href="https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/">That’s Not Normal – the Performance of Odd Floats</a>, Bruce Dawson. This is another good article covering performance issues with IEEE specials on x86 architecture.</em></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IEEE Standard 754 floating point is the most common representation today for real numbers on computers, including Intel-based PC’s, Macin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hi there! What does ‘there’ mean?</title>
    <link href="http://manan.cc/Hi-there-What-does-%E2%80%98there%E2%80%99-mean/2021/07/29/"/>
    <id>http://manan.cc/Hi-there-What-does-%E2%80%98there%E2%80%99-mean/2021/07/29/</id>
    <published>2021-07-29T09:25:40.000Z</published>
    <updated>2021-07-30T01:32:11.254Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NOTE: This page is <strong>COPIED</strong> from “<em><a href="https://oneminuteenglish.org/en/hi-there//">https://oneminuteenglish.org/en/hi-there//</a></em>“ <strong>ONLY</strong> for test.</p></blockquote><p>“Hi there” is a common informal greeting in English. <strong>We often use hi there when we are a little bit surprised to see someone because we didn’t see them at first.</strong></p><p>Hi is an informal way to greet someone in English. You can also use hey or hello. </p><p>“There” in English means that something is far away from you. In this case, <strong>there</strong> doesn’t necessarily mean far away in modern usage. **We use there to be friendly and/or show surprise. **</p><p>“There” doesn’t really have any significant meaning apart from acknowledging that you have seen someone in your presence.</p><h2 id="Is-there-any-difference-between-hi-and-hi-there"><a href="#Is-there-any-difference-between-hi-and-hi-there" class="headerlink" title="Is there any difference between hi and hi there?"></a>Is there any difference between hi and hi there?</h2><p>Hi and Hi there can both be used to greet someone informally. Hi there is usually only used when you already know someone but Hi can be used whether you know someone or not.</p><p>Both Hi and Hi there are common casual ways to say hello to someone in English. </p><h2 id="Is-it-polite-to-say-hi-there"><a href="#Is-it-polite-to-say-hi-there" class="headerlink" title="Is it polite to say hi there?"></a>Is it polite to say hi there?</h2><p>In general, we use hi there in spoken English. It is informal and usually used in a positive, upbeat tone. It is not rude but if you want to be polite you can learn more about polite and formal greetings here.</p><p>You should definitely avoid hi there in emails but it can be quite common in text messages(a more informal medium).</p><p>Hi there is a friendly way to greet someone and acts as a way to show that you are open to a conversation. It is not necessarily polite but people respond well to hi there as informal English becomes more popular. </p><h2 id="Is-hi-unprofessional"><a href="#Is-hi-unprofessional" class="headerlink" title="Is hi unprofessional?"></a>Is hi unprofessional?</h2><p>Hi is fine to use in a professional environment if you already have a good working relationship with someone. </p><p>You should use Hello if you are meeting someone for the first time. It sounds more professional. </p><h2 id="Is-it-better-to-say-hi-or-hey"><a href="#Is-it-better-to-say-hi-or-hey" class="headerlink" title="Is it better to say hi or hey?"></a>Is it better to say hi or hey?</h2><p>Hi and Hey are very similar and almost interchangeable. </p><p>Hey can also be used to call someone’s attention though that can sound rude. </p><p>Both are very common ways to greet someone in English and are especially common among younger people. If you are speaking to someone with authority and is older than you, you might want to use Hello.</p><h2 id="Is-hi-there-flirty-cute"><a href="#Is-hi-there-flirty-cute" class="headerlink" title="Is hi there flirty/cute?"></a>Is hi there flirty/cute?</h2><p>Hi there is a way to show that you are friendly and open to a conversation. Depending on the tone of your voice, you can sound flirty or cute. In a text message, it is not necessarily flirty or cute.</p><h2 id="What-can-I-say-instead-of-hi-there"><a href="#What-can-I-say-instead-of-hi-there" class="headerlink" title="What can I say instead of hi there?"></a>What can I say instead of hi there?</h2><p>If you don’t want to use hi there, you can simply say Hello.</p><p>If you are writing to someone you don’t know, then you can write Hello or Dear with the person’s name depending on how formal you want to be.</p><h2 id="How-to-respond-to-hi-there"><a href="#How-to-respond-to-hi-there" class="headerlink" title="How to respond to hi there?"></a>How to respond to hi there?</h2><p>Hi there is a casual and informal greeting so the best response is something similar but not the same.</p><p>Greeting:    Hi there!</p><p>Response: Hey, How is it going?</p><p>Greeting:    Hi there!</p><p>Response:  Hey, What’s up?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;NOTE: This page is &lt;strong&gt;COPIED&lt;/strong&gt; from “&lt;em&gt;&lt;a href=&quot;https://oneminuteenglish.org/en/hi-there//&quot;&gt;https://oneminutee</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hellowolrd</title>
    <link href="http://manan.cc/hellowolrd/2021/07/29/"/>
    <id>http://manan.cc/hellowolrd/2021/07/29/</id>
    <published>2021-07-29T09:19:36.000Z</published>
    <updated>2021-07-29T09:20:46.209Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#include "stdio.h"</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>printf<span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;#include &quot;stdio.h&quot;&lt;/spa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://manan.cc/hello-world/2021/07/29/"/>
    <id>http://manan.cc/hello-world/2021/07/29/</id>
    <published>2021-07-29T05:19:49.318Z</published>
    <updated>2021-07-29T06:46:52.375Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
